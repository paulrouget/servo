/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

//! The `servo` test application.
//!
//! Creates a `Browser` instance with a simple implementation of
//! the compositor's `WindowMethods` to create a working web browser.
//!
//! This browser's implementation of `WindowMethods` is built on top
//! of [glutin], the cross-platform OpenGL utility and windowing
//! library.
//!
//! For the engine itself look next door in `components/servo/lib.rs`.
//!
//! [glutin]: https://github.com/tomaka/glutin

#![feature(start, core_intrinsics)]

#[cfg(target_os = "android")]
extern crate android_injected_glue;
extern crate backtrace;
// The window backed by glutin
extern crate glutin_app as app;
#[macro_use]
extern crate log;
// The Servo engine
extern crate servo;
#[cfg(not(target_os = "android"))]
#[macro_use]
extern crate sig;

// PAUL: used for Ctrl/Cmd-L to ask for the new url
extern crate tinyfiledialogs;

use backtrace::Backtrace;
use servo::msg::constellation_msg::{Key, KeyModifiers, KeyState, CONTROL, SHIFT, SUPER};
// PAUL: equivalent of constellation
use servo::BrowserManager;
use servo::compositing::windowing::WindowEvent;
use servo::config::opts::{self, ArgumentParsingResult};
use servo::config::servo_version;
// PAUL: FrameId is used to reference one browser instance
use servo::msg::constellation_msg::FrameId;
use servo::script_traits::LoadData;
use servo::servo_url::ServoUrl;
use std::env;
use std::panic;
use std::process;
use std::rc::Rc;
use std::thread;
// PAUL: Events generated by Servo.
use app::window::BrowserEvent;

// PAUL: a naive Tab structure

struct Tabs {
    pub servo: BrowserManager<app::window::Window>,
    pub browsers: Vec<Tab>,
    selected: usize,
}

struct Tab {
    pub url: Option<ServoUrl>,
    frame: FrameId,
}

impl Tabs {
    pub fn new(window: Rc<app::window::Window>, initial_load_data: Vec<LoadData>) -> Tabs {
        // PAUL: create a new instance of Servo, which at the moment is a constellation + a compositor.
        // `window` will be used by the compositor to talk back to the embedder via WindowMethods.
        let mut servo = BrowserManager::new(window.clone());
        servo.setup_logging();
        servo.handle_events(vec![WindowEvent::InitializeCompositing]);
        let mut browsers = vec![];
        for load_data in initial_load_data {
            // Create a new frame + pipeline
            let id = servo.new_browser(load_data, None).unwrap();
            browsers.push(Tab {frame: id, url: None});
        }
        let tabs = Tabs {
            servo: servo,
            browsers: browsers,
            selected: 0,
        };

        tabs.active_selected_browser();
        tabs.print_tabs();

        tabs
    }
    pub fn select_next(&mut self) {
        self.selected = (self.selected + 1) % self.browsers.len();
        self.active_selected_browser();
        self.print_tabs();
    }
    pub fn select_prev(&mut self) {
        if self.selected > 0 {
            self.selected -= 1;
            self.active_selected_browser();
        }
        self.print_tabs();
    }
    pub fn active_tab(&self) -> &Tab {
        &self.browsers[self.selected]
    }
    pub fn add_and_select(&mut self, load_data: LoadData, context: Option<String>) {
        let id = self.servo.new_browser(load_data, context).unwrap();
        self.browsers.push(Tab {frame: id, url: None});
        self.selected = self.browsers.len() - 1;
        self.active_selected_browser();
        self.print_tabs();
    }
    pub fn close_current(&mut self) {
        // PAUL: not implemented
    }

    fn active_selected_browser(&self) {
        // PAUL: this is where we tell WR to display this specific frame tree
        self.servo.set_visible_browser(self.browsers[self.selected].frame);
    }

    fn print_tabs(&self) {
        // PAUL: we can't draw tabs in Glutin, so let's just print the tabs in the terminal
        println!("\n-- TABS --");
        for (i, tab) in self.browsers.iter().enumerate() {
            let url = match tab.url {
                None => "No URL".to_owned(),
                Some(ref url) => url.to_string(),
            };
            println!("{} #{}: {}", if i == self.selected {">"} else {" "}, i, url);
        }
        println!("----------");
    }
}

pub mod platform {
    #[cfg(target_os = "macos")]
    pub use platform::macos::deinit;

    #[cfg(target_os = "macos")]
    pub mod macos;

    #[cfg(not(target_os = "macos"))]
    pub fn deinit() {}
}

#[cfg(not(target_os = "android"))]
fn install_crash_handler() {
    use backtrace::Backtrace;
    use sig::ffi::Sig;
    use std::intrinsics::abort;
    use std::thread;

    fn handler(_sig: i32) {
        let name = thread::current()
            .name()
            .map(|n| format!(" for thread \"{}\"", n))
            .unwrap_or("".to_owned());
        println!("Stack trace{}\n{:?}", name, Backtrace::new());
        unsafe {
            abort();
        }
    }

    signal!(Sig::SEGV, handler); // handle segfaults
    signal!(Sig::ILL, handler); // handle stack overflow and unsupported CPUs
    signal!(Sig::IOT, handler); // handle double panics
    signal!(Sig::BUS, handler); // handle invalid memory access
}

#[cfg(target_os = "android")]
fn install_crash_handler() {}

// Some shortcuts use Cmd on Mac and Control on other systems.
#[cfg(target_os = "macos")]
const CMD_OR_CONTROL: KeyModifiers = SUPER;
#[cfg(not(target_os = "macos"))]
const CMD_OR_CONTROL: KeyModifiers = CONTROL;

fn main() {
    install_crash_handler();

    // Parse the command line options and store them globally
    let opts_result = opts::from_cmdline_args(&*args());

    let content_process_token = if let ArgumentParsingResult::ContentProcess(token) = opts_result {
        Some(token)
    } else {
        if opts::get().is_running_problem_test && ::std::env::var("RUST_LOG").is_err() {
            ::std::env::set_var("RUST_LOG", "compositing::constellation");
        }

        None
    };

    // TODO: once log-panics is released, can this be replaced by
    // log_panics::init()?
    panic::set_hook(Box::new(|info| {
        warn!("Panic hook called.");
        let msg = match info.payload().downcast_ref::<&'static str>() {
            Some(s) => *s,
            None => {
                match info.payload().downcast_ref::<String>() {
                    Some(s) => &**s,
                    None => "Box<Any>",
                }
            },
        };
        let current_thread = thread::current();
        let name = current_thread.name().unwrap_or("<unnamed>");
        if let Some(location) = info.location() {
            println!("{} (thread {}, at {}:{})",
                     msg,
                     name,
                     location.file(),
                     location.line());
        } else {
            println!("{} (thread {})", msg, name);
        }
        if env::var("RUST_BACKTRACE").is_ok() {
            println!("{:?}", Backtrace::new());
        }

        error!("{}", msg);
    }));

    setup_logging();

    if let Some(token) = content_process_token {
        return servo::run_content_process(token);
    }

    if opts::get().is_printing_version {
        println!("{}", servo_version());
        process::exit(0);
    }

    let new_tab_url = ServoUrl::parse("https://duckduckgo.com/html").unwrap();

    let window = app::create_window(None);

    let mut tabs = Tabs::new(
        window.clone(),
        vec![ LoadData::new(ServoUrl::parse("http://example.com").unwrap(), None, None) ]
    );

    // Feed events from the window to the browser until the browser
    // says to stop.
    loop {
        let window_events = window.wait_events();
        let servo_events = window.get_servo_events();
        let mut events: Vec<WindowEvent> = vec![];
        // PAUL: We intercept the glutin events early and see if there are some keyboard shortcuts
        // we want to handle before sending anything to servo
        for event in window_events {
            match event {


                // Open new tab.
                // This won't work because the constellation only support on top level frame at the moment.
                WindowEvent::KeyEvent(Some('t'), _, KeyState::Pressed, CMD_OR_CONTROL) => {
                    println!("cmd-t");
                    let load_data = LoadData::new(new_tab_url.clone(), None, None);
                    tabs.add_and_select(load_data, None);
                },


                // Open a dialog to let the user change the current url
                WindowEvent::KeyEvent(Some('l'), _, KeyState::Pressed, CMD_OR_CONTROL) => {
                    println!("cmd-l");
                    if let Some(request) = tinyfiledialogs::input_box("Enter url", "Url:", "") {
						let url = ServoUrl::parse(&request).or_else(|error| {
                            // Looks like an url, but couldn't parse, maybe http:// was missing
							if request.ends_with(".com") || request.ends_with(".org") || request.ends_with(".net") {
								ServoUrl::parse(&format!("http://{}", request))
							} else {
								Err(error)
							}
						}).or_else(|_| {
							ServoUrl::parse(&format!("https://duckduckgo.com/html/?q={}", request))
						});
						match url {
							Ok(url) => {
                                events.push(WindowEvent::LoadUrl(tabs.active_tab().frame, url.to_string()));
							},
							Err(err) => warn!("Can't parse url: {}", err),
						}
                    }
                },


                // Close tab. Not supported.
                WindowEvent::KeyEvent(Some('w'), _, KeyState::Pressed, SUPER) => {
                    println!("cmd-w");
                    tabs.close_current();
                },


                // Reload current page
                WindowEvent::KeyEvent(Some('r'), _, KeyState::Pressed, SUPER) => {
                    println!("cmd-r");
                    events.push(WindowEvent::Reload(tabs.active_tab().frame));
                },


                // Next tab
                WindowEvent::KeyEvent(_, Key::Tab, KeyState::Pressed, CONTROL) => {
                    println!("ctrl-tab");
                    tabs.select_next();
                },


                // Previous tab
                WindowEvent::KeyEvent(_, Key::Tab, KeyState::Pressed, mods) if mods == SHIFT | CONTROL => {
                    println!("ctrl-shift-tab");
                    tabs.select_prev();
                },

                _ => events.push(event)
            }
        }

        for event in servo_events {
            match event {


                // Update the url of the current tab
                BrowserEvent::SetUrl(frame_id, url) => {
                    tabs.browsers.iter_mut().find(|ref b| b.frame == frame_id).unwrap().url = Some(url);
                    tabs.print_tabs();
				},


                // User Ctrl-clicked on link. Open link in a new browser.
                BrowserEvent::HandleUrl(frame_id, url) => {
                    println!("BrowserEvent::HandleUrl");
                    let load_data = LoadData::new(url.clone(), None, None);
                    tabs.add_and_select(load_data, None);
				},



            }
        }
        let should_continue = tabs.servo.handle_events(events);
        if !should_continue {
            break;
        }
    }

    // unregister_glutin_resize_handler(&window);

    platform::deinit()
}

// PAUL: it was easier for me to just disable this.
// 
// fn register_glutin_resize_handler(window: &Rc<app::window::Window>, browser: &mut BrowserWrapper) {
//     unsafe {
//         window.set_nested_event_loop_listener(browser);
//     }
// }

// fn unregister_glutin_resize_handler(window: &Rc<app::window::Window>) {
//     unsafe {
//         window.remove_nested_event_loop_listener();
//     }
// }

// struct BrowserWrapper {
//     browser: Browser<app::window::Window>,
// }

// impl app::NestedEventLoopListener for BrowserWrapper {
//     fn handle_event_from_nested_event_loop(&mut self, event: WindowEvent) -> bool {
//         let is_resize = match event {
//             WindowEvent::Resize(..) => true,
//             _ => false,
//         };
//         if !self.browser.handle_events(vec![event]) {
//             return false;
//         }
//         if is_resize {
//             self.browser.repaint_synchronously()
//         }
//         true
//     }
// }

#[cfg(target_os = "android")]
fn setup_logging() {
    // Piping logs from stdout/stderr to logcat happens in android_injected_glue.
    ::std::env::set_var("RUST_LOG", "debug");

    unsafe { android_injected_glue::ffi::app_dummy() };
}

#[cfg(not(target_os = "android"))]
fn setup_logging() {}

#[cfg(target_os = "android")]
/// Attempt to read parameters from a file since they are not passed to us in Android environments.
/// The first line should be the "servo" argument and the last should be the URL to load.
/// Blank lines and those beginning with a '#' are ignored.
/// Each line should be a separate parameter as would be parsed by the shell.
/// For example, "servo -p 10 http://en.wikipedia.org/wiki/Rust" would take 4 lines.
fn args() -> Vec<String> {
    use std::error::Error;
    use std::fs::File;
    use std::io::{BufRead, BufReader};

    const PARAMS_FILE: &'static str = "/sdcard/servo/android_params";
    match File::open(PARAMS_FILE) {
        Ok(f) => {
            let mut vec = Vec::new();
            let file = BufReader::new(&f);
            for line in file.lines() {
                let l = line.unwrap().trim().to_owned();
                // ignore blank lines and those that start with a '#'
                match l.is_empty() || l.as_bytes()[0] == b'#' {
                    true => (),
                    false => vec.push(l),
                }
            }
            vec
        },
        Err(e) => {
            debug!("Failed to open params file '{}': {}",
                   PARAMS_FILE,
                   Error::description(&e));
            vec!["servo".to_owned(), "http://en.wikipedia.org/wiki/Rust".to_owned()]
        },
    }
}

#[cfg(not(target_os = "android"))]
fn args() -> Vec<String> {
    use std::env;
    env::args().collect()
}


#[cfg(target_os = "android")]
#[no_mangle]
#[inline(never)]
#[allow(non_snake_case)]
pub extern "C" fn android_main(app: *mut ()) {
    android_injected_glue::android_main2(app as *mut _, move |_, _| main());
}
